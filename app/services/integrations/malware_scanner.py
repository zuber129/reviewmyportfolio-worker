"""
Malware scanning service for PDF files using ClamAV.
Provides virus/malware detection before processing uploaded PDFs.
"""

import time
from io import BytesIO
from typing import Any, Dict

import logging

import structlog
from app.core.config import settings
from pybreaker import CircuitBreaker

logger = structlog.get_logger()
_init_logger = logging.getLogger(__name__)


class MalwareScanner:
    """
    Malware scanner using ClamAV daemon (clamd).
    Falls back gracefully if ClamAV is unavailable (fail-open for development).
    Implements circuit breaker pattern for resilience (G-08).
    """

    def __init__(self):
        self.clamd_available = False
        self.clamd_client = None
        self.circuit_breaker = CircuitBreaker(
            fail_max=5,
            reset_timeout=60,
            name="clamav_scanner",
        )
        self._initialize_clamd()

    def _initialize_clamd(self):
        """Initialize ClamAV daemon connection"""
        if not settings.clamav_enabled:
            _init_logger.info("ClamAV scanning disabled in config")
            return

        try:
            import clamd

            # Use network socket for Docker container communication
            self.clamd_client = clamd.ClamdNetworkSocket(
                host=settings.clamav_host,
                port=settings.clamav_port,
                timeout=10.0,
            )
            # Test connection
            self.clamd_client.ping()
            self.clamd_available = True
            logger.info(
                "clamav_initialized",
                status="available",
                host=settings.clamav_host,
                port=settings.clamav_port,
            )
        except ImportError:
            logger.warning(
                "clamav_not_installed",
                message="clamd library not installed, malware scanning disabled",
            )
        except Exception as e:
            logger.warning(
                "clamav_unavailable",
                error=str(e),
                message="ClamAV daemon not running, malware scanning disabled",
                host=settings.clamav_host,
                port=settings.clamav_port,
            )

    def scan_pdf(self, pdf_bytes: bytes) -> Dict[str, Any]:
        """
        Scan PDF bytes for malware/viruses using ClamAV with circuit breaker.

        Args:
            pdf_bytes: Raw PDF file bytes

        Returns:
            Dict with keys:
            - clean: bool - True if no threats detected
            - threats: List[str] - List of detected threats (empty if clean)
            - scan_time: float - Time taken for scan in seconds
            - scanner_available: bool - Whether ClamAV was available

        Note:
            If ClamAV is unavailable, returns clean=True (fail-open).
            This allows development without ClamAV but should be monitored in production.
        """
        start_time = time.time()

        # If ClamAV not available or disabled, fail open (allow upload)
        if not self.clamd_available or not settings.clamav_enabled:
            scan_time = time.time() - start_time
            logger.warning(
                "malware_scan_skipped",
                reason="clamav_unavailable" if not self.clamd_available else "clamav_disabled",
                scan_time=scan_time,
            )
            return {
                "clean": True,
                "threats": [],
                "scan_time": scan_time,
                "scanner_available": False,
            }

        try:
            # Use circuit breaker to protect against ClamAV failures
            scan_result = self.circuit_breaker.call(
                self._scan_with_clamd,
                pdf_bytes,
            )

            scan_time = time.time() - start_time

            if scan_result["clean"]:
                logger.info(
                    "malware_scan_clean",
                    scan_time=scan_time,
                    file_size=len(pdf_bytes),
                )
            else:
                logger.error(
                    "malware_detected",
                    threats=scan_result["threats"],
                    scan_time=scan_time,
                    file_size=len(pdf_bytes),
                )

            scan_result["scan_time"] = scan_time
            return scan_result

        except Exception as e:
            scan_time = time.time() - start_time
            logger.error(
                "malware_scan_error",
                error=str(e),
                scan_time=scan_time,
                circuit_breaker_state=self.circuit_breaker.current_state,
            )

            # On error, fail open (allow upload) but log the error
            return {
                "clean": True,
                "threats": [],
                "scan_time": scan_time,
                "scanner_available": False,
                "error": str(e),
            }

    def _scan_with_clamd(self, pdf_bytes: bytes) -> Dict[str, Any]:
        """
        Internal method to scan with ClamAV (wrapped by circuit breaker).

        Args:
            pdf_bytes: Raw PDF file bytes

        Returns:
            Dict with clean status and threats list
        """
        # Scan the PDF bytes using instream
        pdf_stream = BytesIO(pdf_bytes)
        scan_result = self.clamd_client.instream(pdf_stream)

        # Parse scan result
        # Result format: {'stream': ('FOUND', 'Eicar-Test-Signature')} or {'stream': ('OK', None)}
        stream_result = scan_result.get("stream", ("OK", None))
        status, threat_name = stream_result

        is_clean = status == "OK"
        threats = [threat_name] if threat_name else []

        return {
            "clean": is_clean,
            "threats": threats,
            "scanner_available": True,
        }

    def scan_pdf_heuristic(self, pdf_bytes: bytes) -> Dict[str, Any]:
        """
        Perform heuristic-based malware checks without ClamAV.
        Checks for suspicious patterns in PDF structure.

        Args:
            pdf_bytes: Raw PDF file bytes

        Returns:
            Dict with same structure as scan_pdf()

        Heuristics:
        - High entropy (potential encryption/obfuscation)
        - Embedded executables
        - JavaScript code
        - Suspicious PDF structure
        """
        start_time = time.time()
        threats = []

        try:
            # Check 1: PDF header validation
            if not pdf_bytes.startswith(b"%PDF"):
                threats.append("Invalid PDF header")

            # Check 2: Look for embedded executables
            executable_signatures = [
                b"MZ",  # Windows PE
                b"\x7fELF",  # Linux ELF
                b"\xca\xfe\xba\xbe",  # Mach-O (macOS)
            ]
            for sig in executable_signatures:
                if sig in pdf_bytes:
                    threats.append(f"Embedded executable detected: {sig.hex()}")

            # Check 3: Look for JavaScript (can be used for exploits)
            if b"/JavaScript" in pdf_bytes or b"/JS" in pdf_bytes:
                logger.warning("pdf_contains_javascript", file_size=len(pdf_bytes))
                # Note: JavaScript in PDFs is not always malicious, so we just warn

            # Check 4: Look for suspicious actions
            suspicious_actions = [
                b"/Launch",  # Can launch external programs
                b"/SubmitForm",  # Can send data externally
                b"/ImportData",  # Can import external data
            ]
            for action in suspicious_actions:
                if action in pdf_bytes:
                    logger.warning(
                        "pdf_suspicious_action",
                        action=action.decode("utf-8", errors="ignore"),
                    )

            # Check 5: Calculate entropy (high entropy = potential encryption/obfuscation)
            entropy = self._calculate_entropy(pdf_bytes[:10000])  # Sample first 10KB
            if entropy > 7.5:  # High entropy threshold
                logger.warning("pdf_high_entropy", entropy=entropy)

            scan_time = time.time() - start_time
            is_clean = len(threats) == 0

            if is_clean:
                logger.info(
                    "heuristic_scan_clean",
                    scan_time=scan_time,
                    entropy=entropy,
                )
            else:
                logger.warning(
                    "heuristic_threats_detected",
                    threats=threats,
                    scan_time=scan_time,
                )

            return {
                "clean": is_clean,
                "threats": threats,
                "scan_time": scan_time,
                "scanner_available": True,
                "scan_type": "heuristic",
            }

        except Exception as e:
            scan_time = time.time() - start_time
            logger.error("heuristic_scan_error", error=str(e))
            return {
                "clean": True,
                "threats": [],
                "scan_time": scan_time,
                "scanner_available": False,
                "error": str(e),
            }

    def _calculate_entropy(self, data: bytes) -> float:
        """
        Calculate Shannon entropy of data.
        High entropy (>7.5) may indicate encryption or compression.

        Args:
            data: Bytes to calculate entropy for

        Returns:
            Entropy value (0-8, where 8 is maximum entropy)
        """
        if not data:
            return 0.0

        import math
        from collections import Counter

        # Count byte frequencies
        byte_counts = Counter(data)
        data_len = len(data)

        # Calculate Shannon entropy
        entropy = 0.0
        for count in byte_counts.values():
            probability = count / data_len
            entropy -= probability * math.log2(probability)

        return entropy


# Global scanner instance
malware_scanner = MalwareScanner()
